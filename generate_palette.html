<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Stateless Palette Generator</title>
    <style>
        :root {
            --bg: #0b0f14;
            --bg2: #0f1521;
            --card: #121821;
            --text: #e7ecf3;
            --muted: #9aa5b1;
            --accent: #3aa3a3;
            --on-accent: #0b0f14;
            --shadow: 0 10px 30px rgba(0, 0, 0, .35);
            --radius: 16px
        }

        * {
            box-sizing: border-box
        }

        html,
        body {
            min-height: 100%;
            overflow: auto
        }

        body {
            margin: 0;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
            background: radial-gradient(1200px 900px at 20% 0%, var(--bg2), var(--bg));
            color: var(--text);
            line-height: 1.5;
            transition: background-color .25s ease, color .25s ease
        }

        .wrap {
            max-width: 1200px;
            margin: 32px auto;
            padding: 0 20px;
            display: grid;
            grid-template-columns: 1fr 1.2fr;
            gap: 24px
        }

        .page-title {
            grid-column: 1/-1;
            font-size: 28px;
            font-weight: 800;
            margin: 0 0 8px;
            letter-spacing: .3px
        }

        .card {
            background: linear-gradient(180deg, rgba(255, 255, 255, .02), rgba(255, 255, 255, .01));
            border: 1px solid rgba(255, 255, 255, .06);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 16px;
            transition: background-color .25s ease, border-color .25s ease, box-shadow .25s ease, color .25s ease
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px
        }

        .row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px
        }

        label {
            font-weight: 600;
            font-size: 12px;
            color: var(--muted);
            text-transform: uppercase;
            letter-spacing: .08em
        }

        .ctrl {
            background: var(--card);
            border: 1px solid rgba(255, 255, 255, .08);
            border-radius: 12px;
            padding: 10px 12px;
            color: var(--text);
            font-size: 14px;
            outline: none;
            width: 100%;
            transition: background-color .25s ease, border-color .25s ease, color .25s ease, box-shadow .25s ease
        }

        input[type=number].ctrl {
            appearance: textfield
        }

        .wheel {
            display: grid;
            grid-template-columns: auto;
            align-items: center
        }

        #wheel {
            width: 100%;
            max-width: 220px;
            aspect-ratio: 1/1;
            border-radius: 12px;
            display: block;
            background: var(--card);
            border: 1px solid rgba(255, 255, 255, .12);
            touch-action: pan-y pinch-zoom
        }

        .wheel-wrap {
            display: flex;
            align-items: center;
            gap: 12px
        }

        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px
        }

        .canvas-card {
            position: relative
        }

        canvas {
            width: 100%;
            height: auto;
            display: block;
            background: #000;
            border-radius: 12px
        }

        .colors {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 8px;
            margin-top: 10px
        }

        .swatch {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            border-radius: 12px;
            background: rgba(255, 255, 255, .03);
            border: 1px solid rgba(255, 255, 255, .06);
            cursor: pointer;
            user-select: none;
            transition: background-color .15s ease, transform .06s ease
        }

        .swatch:hover {
            background: rgba(255, 255, 255, .06)
        }

        .swatch:active {
            transform: translateY(1px)
        }

        .dot {
            width: 20px;
            height: 20px;
            border-radius: 6px;
            border: 1px solid rgba(0, 0, 0, .2)
        }

        .hex {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 12px
        }

        .toast {
            position: fixed;
            left: 50%;
            bottom: 24px;
            transform: translateX(-50%) translateY(20px);
            opacity: 0;
            pointer-events: none;
            background: var(--card);
            color: var(--text);
            border: 1px solid rgba(255, 255, 255, .08);
            border-radius: 999px;
            padding: 8px 12px;
            font-size: 12px;
            box-shadow: var(--shadow);
            transition: opacity .2s ease, transform .2s ease
        }

        .toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0)
        }

        @media (max-width:900px) {
            .wrap {
                grid-template-columns: 1fr
            }

            .row {
                grid-template-columns: 1fr
            }

            .grid-2 {
                grid-template-columns: 1fr
            }
        }

        @media (prefers-reduced-motion:reduce) {

            .card,
            .ctrl,
            body,
            .swatch,
            .toast {
                transition: none !important
            }
        }

        @media (orientation:landscape) {

            html,
            body {
                height: 100%;
                overflow: hidden
            }
        }
    </style>
</head>

<body>
    <div class="wrap">
        <h1 class="page-title">Stateless Palette Generator</h1>
        <section class="card">
            <div class="controls">
                <div class="row">
                    <div>
                        <label for="hexInput">Base color (hex)</label>
                        <input id="hexInput" class="ctrl" value="#0FA3A3" spellcheck="false" />
                    </div>
                    <div>
                        <label for="wheel">Color wheel</label>
                        <div class="wheel-wrap">
                            <canvas id="wheel" width="220" height="220" aria-label="Color wheel" tabindex="0"></canvas>
                        </div>
                    </div>
                </div>
                <div class="row">
                    <div>
                        <label for="size">Canvas size (px)</label>
                        <input id="size" class="ctrl" type="number" min="128" max="4096" step="1" value="1024" />
                    </div>
                    <div>
                        <label for="tile">Tile size (px)</label>
                        <input id="tile" class="ctrl" type="number" min="16" max="1024" step="1" value="120" />
                    </div>
                </div>
                <div class="row">
                    <div>
                        <label for="radius">Corner radius (px)</label>
                        <input id="radius" class="ctrl" type="number" min="0" max="160" step="1" value="0" />
                    </div>
                </div>
            </div>
            <div id="colors" class="colors" aria-live="polite" aria-busy="false"></div>
        </section>
        <section class="card canvas-card">
            <canvas id="cnv" width="1024" height="1024"></canvas>
        </section>
    </div>
    <div id="toast" role="status" aria-live="polite" class="toast" hidden></div>
    <script>
        const HEX_RE = /^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/;
        function parseHexColor(s) { const m = (s + "").trim().match(HEX_RE); if (!m) throw new Error(`Invalid hex color: ${s}. Expected #00aacc or #0ac`); const hex = m[1]; const toByte = str => parseInt(str, 16); if (hex.length === 3) return [toByte(hex[0] + hex[0]), toByte(hex[1] + hex[1]), toByte(hex[2] + hex[2])]; return [toByte(hex.slice(0, 2)), toByte(hex.slice(2, 4)), toByte(hex.slice(4, 6))] }
        function rgbToHex([r, g, b]) { const h = v => v.toString(16).padStart(2, "0").toUpperCase(); return `#${h(r)}${h(g)}${h(b)}` }
        function rgb_to_hls(r, g, b) { r /= 255; g /= 255; b /= 255; const maxc = Math.max(r, g, b), minc = Math.min(r, g, b); let h = 0, s = 0; const l = (minc + maxc) / 2; if (minc !== maxc) { const diff = maxc - minc; s = l <= .5 ? diff / (maxc + minc) : diff / (2 - maxc - minc); const rc = (maxc - r) / diff, gc = (maxc - g) / diff, bc = (maxc - b) / diff; if (r === maxc) h = bc - gc; else if (g === maxc) h = 2 + rc - bc; else h = 4 + gc - rc; h = (h / 6) % 1; if (h < 0) h += 1 } return [h, l, s] }
        function _v(m1, m2, h) { h = (h % 1 + 1) % 1; if (h < 1 / 6) return m1 + (m2 - m1) * 6 * h; if (h < 1 / 2) return m2; if (h < 2 / 3) return m1 + (m2 - m1) * (2 / 3 - h) * 6; return m1 }
        function hls_to_rgb(h, l, s) { if (s === 0) { const v = Math.round(l * 255); return [v, v, v] } const m2 = l <= .5 ? l * (1 + s) : l + s - l * s; const m1 = 2 * l - m2; const r = Math.round(_v(m1, m2, h + 1 / 3) * 255); const g = Math.round(_v(m1, m2, h) * 255); const b = Math.round(_v(m1, m2, h - 1 / 3) * 255); return [r, g, b] }
        function adjustLightness(rgb, factor) { let [h, l, s] = rgb_to_hls(rgb[0], rgb[1], rgb[2]); if (factor >= 0) l = l + (1 - l) * factor; else l = l * (1 + factor); l = Math.max(0, Math.min(1, l)); return hls_to_rgb(h, l, s) }
        function make_shades_and_tints(base) { const light_factors = [.45, .36, .28, .20, .12, .06]; const dark_factors = [-.50, -.40, -.30, -.22, -.15, -.08]; const out = []; light_factors.forEach((f, i) => out.push([`light_${i + 1}`, adjustLightness(base, f)])); dark_factors.forEach((f, i) => out.push([`dark_${i + 1}`, adjustLightness(base, f)])); return out }
        function layout_positions(size, sq) { const anchors = [[.16, .06], [.30, .06], [.05, .22], [.05, .38], [.90, .07], [.90, .18], [.90, .29], [.90, .66], [.90, .78], [.05, .90], [.17, .90], [.29, .90], [.41, .90], [.62, .90], [.74, .90]]; const max = Math.max(0, size - sq); return anchors.map(([ax, ay]) => [Math.round(ax * max), Math.round(ay * max)]) }
        function roundedRect(ctx, x, y, w, h, r) { if (!r) { ctx.fillRect(x, y, w, h); return } const rr = Math.min(r, w / 2, h / 2); ctx.beginPath(); ctx.moveTo(x + rr, y); ctx.lineTo(x + w - rr, y); ctx.arcTo(x + w, y, x + w, y + rr, rr); ctx.lineTo(x + w, y + h - rr); ctx.arcTo(x + w, y + h, x + w - rr, y + h, rr); ctx.lineTo(x + rr, y + h); ctx.arcTo(x, y + h, x, y + h - rr, rr); ctx.lineTo(x, y + rr); ctx.arcTo(x, y, x + rr, y, rr); ctx.closePath(); ctx.fill() }
        function relativeLuminance([r, g, b]) { const srgb = [r, g, b].map(v => { v /= 255; return v <= .03928 ? v / 12.92 : Math.pow((v + .055) / 1.055, 2.4) }); return .2126 * srgb[0] + .7152 * srgb[1] + .0722 * srgb[2] }
        function chooseTextColor(rgb) { const L = relativeLuminance(rgb); const crWhite = (1 + .05) / (L + .05); const crBlack = (L + .05) / (.05); return crWhite >= crBlack ? "#FFFFFF" : "#000000" }
        const setVar = (k, v) => document.documentElement.style.setProperty(`--${k}`, v);
        const theme = new Proxy({}, { set(o, p, val) { o[p] = val; const cssKey = String(p).replace(/[A-Z]/g, m => "-" + m.toLowerCase()); setVar(cssKey, val); return true } });
        function applyThemeFromPalette(baseRGB, lights, darks) { const bgRGB = darks[0] || baseRGB; const cardRGB = darks[2] || darks[darks.length - 1] || baseRGB; const accentRGB = baseRGB; const bg2RGB = adjustLightness(bgRGB, .2); theme.bg = rgbToHex(bgRGB); theme.bg2 = rgbToHex(bg2RGB); theme.card = rgbToHex(cardRGB); theme.accent = rgbToHex(accentRGB); theme.text = chooseTextColor(bgRGB); theme.onAccent = chooseTextColor(accentRGB); theme.muted = rgbToHex(lights[4] || lights[3] || lights[0] || baseRGB) }
        function renderPalette() { const hexInput = document.getElementById("hexInput"); const sizeEl = document.getElementById("size"); const tileEl = document.getElementById("tile"); const radiusEl = document.getElementById("radius"); const canvas = document.getElementById("cnv"); const colorsPanel = document.getElementById("colors"); let baseHex = hexInput.value.trim(); try { const baseRGB = parseHexColor(baseHex); const size = Math.max(16, Math.min(4096, parseInt(sizeEl.value || "1024", 10))); let sq = Math.max(4, Math.min(1024, parseInt(tileEl.value || "120", 10))); sq = Math.min(sq, size); const radius = Math.max(0, Math.min(200, parseInt(radiusEl.value || "0", 10))); const dpr = Math.max(1, window.devicePixelRatio || 1); if (canvas.width !== size * dpr) canvas.width = size * dpr; if (canvas.height !== size * dpr) canvas.height = size * dpr; const ctx = canvas.getContext("2d"); const palette = make_shades_and_tints(baseRGB); const lights = palette.filter(([l]) => l.startsWith("light")).map(([, rgb]) => rgb); const darks = palette.filter(([l]) => l.startsWith("dark")).map(([, rgb]) => rgb); applyThemeFromPalette(baseRGB, lights, darks); const buffer = document.createElement("canvas"); buffer.width = size * dpr; buffer.height = size * dpr; const bctx = buffer.getContext("2d"); bctx.setTransform(dpr, 0, 0, dpr, 0, 0); bctx.fillStyle = rgbToHex(baseRGB); bctx.fillRect(0, 0, size, size); const color_order = [lights[2], lights[1], darks[1], darks[2], lights[0], darks[0], darks[3], darks[4], darks[2], lights[3], lights[1], darks[2], darks[4], lights[0], lights[2]]; const positions = layout_positions(size, sq); const n = Math.min(positions.length, color_order.length); bctx.save(); for (let i = 0; i < n; i++) { const [x, y] = positions[i]; const [r, g, b] = color_order[i]; bctx.fillStyle = rgbToHex([r, g, b]); roundedRect(bctx, x, y, sq, sq, radius) } bctx.restore(); ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.drawImage(buffer, 0, 0); const used = [baseRGB, ...lights, ...darks].map(rgbToHex); colorsPanel.innerHTML = used.map(hx => `<div class="swatch" title="Click to copy ${hx}"><div class="dot" style="background:${hx}"></div><div class="hex">${hx}</div></div>`).join("") } catch (err) { document.getElementById("colors").innerHTML = `<div style="color:#f88">${err.message}</div>` } }
        function rafDebounce(fn, wait = 60) { let t = 0, raf = 0; return (...args) => { clearTimeout(t); t = setTimeout(() => { if (raf) cancelAnimationFrame(raf); raf = requestAnimationFrame(() => fn(...args)) }, wait) } }
        const scheduleRender = rafDebounce(renderPalette, 60);
        function showToast(msg) { const toast = document.getElementById("toast"); toast.textContent = msg; toast.hidden = false; toast.classList.add("show"); clearTimeout(showToast._t); showToast._t = setTimeout(() => { toast.classList.remove("show") }, 1100) }
        document.getElementById("toast").addEventListener("transitionend", e => { const t = e.currentTarget; if (!t.classList.contains("show")) t.hidden = true });
        document.getElementById("colors").addEventListener("click", e => { const sw = e.target.closest(".swatch"); if (!sw) return; const hx = sw.querySelector(".hex"); const text = hx && hx.textContent.trim(); if (!text) return; if (navigator.clipboard && navigator.clipboard.writeText) { navigator.clipboard.writeText(text).then(() => showToast(`Copied ${text}`)).catch(() => showToast("Copy failed")) } else { const ta = document.createElement("textarea"); ta.value = text; document.body.appendChild(ta); ta.select(); try { document.execCommand("copy"); showToast(`Copied ${text}`) } catch { showToast("Copy failed") } document.body.removeChild(ta) } });
        function drawWheel() { const wheel = document.getElementById("wheel"); const ctx = wheel.getContext("2d"); const dpr = Math.max(1, window.devicePixelRatio || 1); const cssSize = wheel.clientWidth || 220; wheel.width = Math.round(cssSize * dpr); wheel.height = Math.round(cssSize * dpr); const cx = wheel.width / 2, cy = wheel.height / 2; const R = Math.min(cx, cy) - 2 * dpr; const image = ctx.createImageData(wheel.width, wheel.height); const data = image.data; let base; try { base = parseHexColor(document.getElementById("hexInput").value.trim()) } catch { base = [15, 163, 163] } let [, l0] = rgb_to_hls(base[0], base[1], base[2]); for (let y = 0; y < wheel.height; y++) { for (let x = 0; x < wheel.width; x++) { const dx = x - cx, dy = y - cy; const dist = Math.sqrt(dx * dx + dy * dy); if (dist <= R) { let ang = Math.atan2(dy, dx); let h = ang / (2 * Math.PI); if (h < 0) h += 1; let sat = Math.min(1, dist / R); const [rr, gg, bb] = hls_to_rgb(h, l0, sat); const idx = (y * wheel.width + x) * 4; data[idx] = rr; data[idx + 1] = gg; data[idx + 2] = bb; data[idx + 3] = 255 } } } ctx.putImageData(image, 0, 0); ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI * 2); ctx.strokeStyle = 'rgba(255,255,255,.15)'; ctx.lineWidth = 2 * dpr; ctx.stroke(); const [bh, bl, bs] = rgb_to_hls(base[0], base[1], base[2]); const ang = bh * 2 * Math.PI; const rad = bs * R; const px = cx + Math.cos(ang) * rad; const py = cy + Math.sin(ang) * rad; ctx.beginPath(); ctx.arc(px, py, 5 * dpr, 0, Math.PI * 2); ctx.fillStyle = "#000"; ctx.globalAlpha = .4; ctx.fill(); ctx.globalAlpha = 1; ctx.beginPath(); ctx.arc(px, py, 4 * dpr, 0, Math.PI * 2); ctx.strokeStyle = "#fff"; ctx.lineWidth = 2 * dpr; ctx.stroke() }
        function handleWheelPointer(ev) { const wheel = document.getElementById("wheel"); const rect = wheel.getBoundingClientRect(); const cx = rect.left + rect.width / 2; const cy = rect.top + rect.height / 2; const x = ev.clientX - cx; const y = ev.clientY - cy; const R = Math.min(rect.width, rect.height) / 2 - 2; const dist = Math.min(R, Math.hypot(x, y)); let h = Math.atan2(y, x) / (2 * Math.PI); if (h < 0) h += 1; let s = Math.min(1, dist / R); const base = parseHexColor(document.getElementById("hexInput").value.trim()); const [, l] = rgb_to_hls(base[0], base[1], base[2]); const rgb = hls_to_rgb(h, l, s); document.getElementById("hexInput").value = rgbToHex(rgb); scheduleRender(); drawWheel() }
        function bindWheel() { const wheel = document.getElementById("wheel"); let dragging = false; wheel.addEventListener("pointerdown", e => { dragging = true; handleWheelPointer(e) }); wheel.addEventListener("pointermove", e => { if (dragging) handleWheelPointer(e) }); wheel.addEventListener("pointerup", () => { dragging = false }); wheel.addEventListener("pointercancel", () => { dragging = false }); wheel.addEventListener("pointerleave", () => { dragging = false }); window.addEventListener("resize", () => { drawWheel() }); wheel.addEventListener("keydown", e => { if (e.key === "ArrowLeft" || e.key === "ArrowRight" || e.key === "ArrowUp" || e.key === "ArrowDown") { const base = parseHexColor(document.getElementById("hexInput").value.trim()); let [h, l, s] = rgb_to_hls(base[0], base[1], base[2]); if (e.key === "ArrowLeft") h -= .005; if (e.key === "ArrowRight") h += .005; if (e.key === "ArrowDown") s = Math.max(0, s - .01); if (e.key === "ArrowUp") s = Math.min(1, s + .01); if (h < 0) h += 1; if (h > 1) h -= 1; const rgb = hls_to_rgb(h, l, s); document.getElementById("hexInput").value = rgbToHex(rgb); scheduleRender(); drawWheel() } }) }
        ["hexInput", "size", "tile", "radius"].forEach(id => { document.getElementById(id).addEventListener("input", () => { scheduleRender(); drawWheel() }) });
        renderPalette(); bindWheel(); drawWheel();
    </script>
</body>

</html>
