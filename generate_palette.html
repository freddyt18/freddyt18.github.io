<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Stateless Palette Generator</title>
  <style>
    :root {
      --bg: #0b0f14;
      --bg2: #0f1521; /* lighter background ring for gradient */
      --card: #121821;
      --text: #e7ecf3;
      --muted: #9aa5b1;
      --accent: #3aa3a3;
      --on-accent: #0b0f14; /* text on accent */
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 16px;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1200px 900px at 20% 0%, var(--bg2), var(--bg));
      color: var(--text);
      line-height: 1.5;
    }
    .wrap {
      max-width: 1200px;
      margin: 32px auto;
      padding: 0 20px;
      display: grid;
      grid-template-columns: 1fr 1.2fr;
      gap: 24px;
    }
    header h1 { font-size: 24px; margin: 0 0 4px; letter-spacing: .3px; }
    header p { margin: 0; color: var(--muted); font-size: 14px; }

    .card {
      background: linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.01));
      border: 1px solid rgba(255,255,255,.06);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 16px;
    }
    .controls { display: grid; grid-template-columns: 1fr; gap: 12px; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }

    label { font-weight: 600; font-size: 12px; color: var(--muted); text-transform: uppercase; letter-spacing: .08em; }
    .ctrl {
      background: var(--card);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 12px;
      padding: 10px 12px;
      color: var(--text);
      font-size: 14px;
      outline: none;
      width: 100%;
    }
    input[type="number"].ctrl { appearance: textfield; }
    input[type="color"] {
      width: 100%; height: 40px; border-radius: 12px; border: 1px solid rgba(255,255,255,.12);
      background: var(--card); padding: 0;
    }

    /* Accent button that adapts in real time via CSS vars */
    .btn {
      cursor: pointer;
      font-weight: 700;
      background: var(--accent);
      color: var(--on-accent);
      border: 1px solid rgba(0,0,0,.25);
      border-radius: 12px;
      padding: 10px 12px;
      box-shadow: 0 6px 14px rgba(0,0,0,.25);
      transition: transform .06s ease, filter .12s ease;
    }
    .btn:hover { filter: brightness(1.05); }
    .btn:active { transform: translateY(1px); }

    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }

    .canvas-card { position: relative; }
    canvas { width: 100%; height: auto; display: block; background: #000; border-radius: 12px; }

    .colors {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 8px; margin-top: 10px;
    }
    .swatch {
      display: flex; align-items: center; gap: 8px; padding: 8px; border-radius: 12px;
      background: rgba(255,255,255,.03); border: 1px solid rgba(255,255,255,.06);
    }
    .dot { width: 20px; height: 20px; border-radius: 6px; border: 1px solid rgba(0,0,0,.2); }
    .hex { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; }

    @media (max-width: 900px) {
      .wrap { grid-template-columns: 1fr; }
      .row { grid-template-columns: 1fr; }
      .grid-2 { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header class="card">
      <h1>Stateless Palette Generator</h1>
      <p>Ports your <code>generate_palette.py</code> to the browser. No files saved â€” it just renders to the canvas.</p>
    </header>

    <section class="card">
      <div class="controls">
        <div class="row">
          <div>
            <label for="hexInput">Base color (hex)</label>
            <input id="hexInput" class="ctrl" value="#0FA3A3" spellcheck="false" />
          </div>
          <div>
            <label for="picker">Quick pick</label>
            <input id="picker" type="color" value="#0FA3A3" />
          </div>
        </div>
        <div class="row">
          <div>
            <label for="size">Canvas size (px)</label>
            <input id="size" class="ctrl" type="number" min="128" max="4096" step="1" value="1024" />
          </div>
          <div>
            <label for="tile">Tile size (px)</label>
            <input id="tile" class="ctrl" type="number" min="16" max="1024" step="1" value="120" />
          </div>
        </div>
        <div class="row">
          <div>
            <label for="radius">Corner radius (px)</label>
            <input id="radius" class="ctrl" type="number" min="0" max="160" step="1" value="0" />
          </div>
          <div>
            <label>&nbsp;</label>
            <button id="render" class="ctrl btn">Render Palette</button>
          </div>
        </div>
      </div>

      <div id="colors" class="colors" aria-live="polite" aria-busy="false"></div>
    </section>

    <section class="card canvas-card">
      <canvas id="cnv" width="1024" height="1024"></canvas>
    </section>
  </div>

  <script>
    // === Utilities: hex/rgb and HLS (Python colorsys-compatible) ===
    const HEX_RE = /^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/;

    function parseHexColor(s) {
      const m = (s + '').trim().match(HEX_RE);
      if (!m) throw new Error(`Invalid hex color: ${s}. Expected #00aacc or #0ac`);
      const hex = m[1];
      const toByte = (str) => parseInt(str, 16);
      if (hex.length === 3) {
        return [toByte(hex[0] + hex[0]), toByte(hex[1] + hex[1]), toByte(hex[2] + hex[2])];
      }
      return [toByte(hex.slice(0,2)), toByte(hex.slice(2,4)), toByte(hex.slice(4,6))];
    }

    function rgbToHex([r,g,b]) {
      const h = (v) => v.toString(16).padStart(2, '0').toUpperCase();
      return `#${h(r)}${h(g)}${h(b)}`;
    }

    // Python's colorsys rgb_to_hls
    function rgb_to_hls(r, g, b) {
      r /= 255; g /= 255; b /= 255;
      const maxc = Math.max(r,g,b), minc = Math.min(r,g,b);
      let h = 0, s = 0; const l = (minc + maxc) / 2;
      if (minc !== maxc) {
        const diff = maxc - minc;
        s = l <= 0.5 ? diff / (maxc + minc) : diff / (2 - maxc - minc);
        const rc = (maxc - r) / diff;
        const gc = (maxc - g) / diff;
        const bc = (maxc - b) / diff;
        if (r === maxc) h = bc - gc;
        else if (g === maxc) h = 2 + rc - bc;
        else h = 4 + gc - rc;
        h = (h / 6) % 1; if (h < 0) h += 1;
      }
      return [h, l, s];
    }

    function _v(m1, m2, h) {
      h = (h % 1 + 1) % 1;
      if (h < 1/6) return m1 + (m2 - m1) * 6 * h;
      if (h < 1/2) return m2;
      if (h < 2/3) return m1 + (m2 - m1) * (2/3 - h) * 6;
      return m1;
    }

    // Python's colorsys hls_to_rgb
    function hls_to_rgb(h, l, s) {
      if (s === 0) {
        const v = Math.round(l * 255);
        return [v, v, v];
      }
      const m2 = l <= 0.5 ? l * (1 + s) : l + s - l * s;
      const m1 = 2 * l - m2;
      const r = Math.round(_v(m1, m2, h + 1/3) * 255);
      const g = Math.round(_v(m1, m2, h) * 255);
      const b = Math.round(_v(m1, m2, h - 1/3) * 255);
      return [r, g, b];
    }

    function adjustLightness(rgb, factor) {
      let [h, l, s] = rgb_to_hls(rgb[0], rgb[1], rgb[2]);
      if (factor >= 0) l = l + (1 - l) * factor; else l = l * (1 + factor);
      l = Math.max(0, Math.min(1, l));
      return hls_to_rgb(h, l, s);
    }

    function make_shades_and_tints(base) {
      const light_factors = [0.45, 0.36, 0.28, 0.20, 0.12, 0.06];
      const dark_factors  = [-0.50, -0.40, -0.30, -0.22, -0.15, -0.08];
      const out = [];
      light_factors.forEach((f, i) => out.push([`light_${i+1}`, adjustLightness(base, f)]));
      dark_factors.forEach((f, i)  => out.push([`dark_${i+1}`,  adjustLightness(base, f)]));
      return out;
    }

    function layout_positions(size) {
      const anchors = [
        [0.16, 0.06], [0.30, 0.06],                 // top: two squares near the left
        [0.05, 0.22], [0.05, 0.38],                 // left side: two stacked
        [0.90, 0.07], [0.90, 0.18], [0.90, 0.29],   // right side (upper): three stacked
        [0.90, 0.66], [0.90, 0.78],                 // right side (lower): two stacked
        [0.05, 0.90], [0.17, 0.90], [0.29, 0.90], [0.41, 0.90],  // bottom left: four in a row
        [0.62, 0.90], [0.74, 0.90]                  // bottom right: two in a row
      ];
      return anchors.map(([ax, ay]) => [Math.round(ax * size), Math.round(ay * size)]);
    }

    function roundedRect(ctx, x, y, w, h, r) {
      if (!r) { ctx.fillRect(x, y, w, h); return; }
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x + rr, y);
      ctx.lineTo(x + w - rr, y);
      ctx.arcTo(x + w, y, x + w, y + rr, rr);
      ctx.lineTo(x + w, y + h - rr);
      ctx.arcTo(x + w, y + h, x + w - rr, y + h, rr);
      ctx.lineTo(x + rr, y + h);
      ctx.arcTo(x, y + h, x, y + h - rr, rr);
      ctx.lineTo(x, y + rr);
      ctx.arcTo(x, y, x + rr, y, rr);
      ctx.closePath();
      ctx.fill();
    }

    // === Accessibility helpers ===
    function relativeLuminance([r,g,b]) {
      const srgb = [r,g,b].map(v => {
        v /= 255; return v <= 0.03928 ? v/12.92 : Math.pow((v+0.055)/1.055, 2.4);
      });
      return 0.2126*srgb[0] + 0.7152*srgb[1] + 0.0722*srgb[2];
    }
    function chooseTextColor(rgb) {
      const L = relativeLuminance(rgb);
      const crWhite = (1 + 0.05) / (L + 0.05);
      const crBlack = (L + 0.05) / (0 + 0.05);
      return crWhite >= crBlack ? '#FFFFFF' : '#000000';
    }

    // === Theme proxy: writing properties updates CSS vars in real-time ===
    const setVar = (k, v) => document.documentElement.style.setProperty(`--${k}`, v);
    const theme = new Proxy({}, {
      set(obj, prop, value) {
        obj[prop] = value;
        const cssKey = String(prop).replace(/[A-Z]/g, m => '-' + m.toLowerCase());
        setVar(cssKey, value);
        return true;
      }
    });

    function applyThemeFromPalette(baseRGB, lights, darks) {
      const bgRGB = darks[0] || baseRGB;
      const cardRGB = darks[2] || darks[darks.length-1] || baseRGB;
      const accentRGB = baseRGB;
      const bg2RGB = adjustLightness(bgRGB, 0.2);
      theme.bg = rgbToHex(bgRGB);
      theme.bg2 = rgbToHex(bg2RGB);
      theme.card = rgbToHex(cardRGB);
      theme.accent = rgbToHex(accentRGB);
      theme.text = chooseTextColor(bgRGB);
      theme.onAccent = chooseTextColor(accentRGB);
      theme.muted = rgbToHex(lights[4] || lights[3] || lights[0] || baseRGB);
    }

    function renderPalette() {
      const hexInput = document.getElementById('hexInput');
      const picker = document.getElementById('picker');
      const sizeEl = document.getElementById('size');
      const tileEl = document.getElementById('tile');
      const radiusEl = document.getElementById('radius');
      const canvas = document.getElementById('cnv');
      const colorsPanel = document.getElementById('colors');

      let baseHex = hexInput.value.trim();
      try {
        const baseRGB = parseHexColor(baseHex);
        // sync picker to valid hex
        picker.value = rgbToHex(baseRGB);

        const size = Math.max(16, Math.min(4096, parseInt(sizeEl.value || '1024', 10)));
        const sq   = Math.max(4, Math.min(1024, parseInt(tileEl.value || '120', 10)));
        const radius = Math.max(0, Math.min(200, parseInt(radiusEl.value || '0', 10)));
        canvas.width = size; canvas.height = size;
        const ctx = canvas.getContext('2d');

        // Palette
        const palette = make_shades_and_tints(baseRGB);
        const lights = palette.filter(([label]) => label.startsWith('light')).map(([,rgb]) => rgb);
        const darks  = palette.filter(([label]) => label.startsWith('dark')).map(([,rgb]) => rgb);

        // === Real-time theme update via proxy ===
        applyThemeFromPalette(baseRGB, lights, darks);

        // Background = base color
        ctx.fillStyle = rgbToHex(baseRGB);
        ctx.fillRect(0, 0, size, size);

        // Order and draw
        const color_order = [
          lights[2], lights[1],
          darks[1], darks[2],
          lights[0], darks[0], darks[3],
          darks[4], darks[2],
          lights[3], lights[1], darks[2], darks[4],
          lights[0], lights[2]
        ];
        const positions = layout_positions(size);

        const n = Math.min(positions.length, color_order.length);
        ctx.save();
        for (let i = 0; i < n; i++) {
          const [x, y] = positions[i];
          const [r, g, b] = color_order[i];
          ctx.fillStyle = rgbToHex([r,g,b]);
          roundedRect(ctx, x, y, sq, sq, radius);
        }
        ctx.restore();

        // Update color list: base + lights + darks
        const used = [baseRGB, ...lights, ...darks].map(rgbToHex);
        colorsPanel.innerHTML = used.map(hx => `
          <div class="swatch">
            <div class="dot" style="background:${hx}"></div>
            <div class="hex">${hx}</div>
          </div>
        `).join('');
      } catch (err) {
        colorsPanel.innerHTML = `<div style="color:#f88">${err.message}</div>`;
      }
    }

    // === Wire up controls ===
    const hexInput = document.getElementById('hexInput');
    const picker = document.getElementById('picker');
    const sizeEl = document.getElementById('size');
    const tileEl = document.getElementById('tile');
    const radiusEl = document.getElementById('radius');
    const renderBtn = document.getElementById('render');

    function debounce(fn, ms) { let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); }; }
    const scheduleRender = debounce(renderPalette, 80);

    [hexInput, sizeEl, tileEl, radiusEl].forEach(el => el.addEventListener('input', scheduleRender));
    picker.addEventListener('input', () => { hexInput.value = picker.value; scheduleRender(); });
    renderBtn.addEventListener('click', renderPalette);

    // Initial render
    renderPalette();
  </script>
</body>
</html>
